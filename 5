<#
.SYNOPSIS
    Generates a comprehensive report on specified Active Directory users.
.DESCRIPTION
    This script retrieves a list of Active Directory users based on a configurable LDAP filter.
    For each user, it reports on their sAMAccountName, account type, manager details (Name, Email, Department),
    creation date, password last set date, and the age of the password in days. It checks for membership
    in a defined list of "in-scope" groups. It also verifies the existence of corresponding
    '[sAMAccountName]_RW' and '[sAMAccountName]_RO' groups, reports on their managers, and checks if
    the user's manager is a member of these groups.

.NOTES
    Version: 1.9 (Corrected)
    Author: Senior PowerShell and Active Directory Automation Specialist
    Prerequisites: Active Directory module for Windows PowerShell (RSAT-AD-PowerShell).
    Execution Policy: The script must be run under an execution policy that allows script execution (e.g., RemoteSigned).
    Permissions: The executing account needs read permissions for user and group objects in Active Directory.
#>

#================================================================================
# SCRIPT EXECUTION WRAPPER WITH LOGGING AND ERROR HANDLING
#================================================================================

Try {
    #----------------------------------------------------------------------------
    # CONFIGURATION
    #----------------------------------------------------------------------------
    $OutputPath = "C:\Temp\AD_User_Group_Report.csv"
    $LogPath = "C:\Temp\Logs"
    $LDAPFilter = "(&(objectCategory=person)(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2))(|(company=*Resource*)(company=Resource-Service))(!(company=Resource-Admin)))"
    $InScopeGroupNames = @("phase1", "phase2", "inscope")
    $NonInteractiveGroupName = "deny_interactvie"

    #----------------------------------------------------------------------------
    # INITIALIZATION
    #----------------------------------------------------------------------------
    if (-not (Test-Path -Path $LogPath -PathType Container)) {
        Write-Verbose "Log directory not found. Creating it at: $LogPath"
        New-Item -Path $LogPath -ItemType Directory -Force | Out-Null
    }
    $Timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
    $TranscriptPath = Join-Path -Path $LogPath -ChildPath "AD_User_Report_$Timestamp.log"
    Start-Transcript -Path $TranscriptPath
    Write-Host "Script execution started. Logging to: $TranscriptPath"

    if (-not (Get-Module -Name ActiveDirectory -ListAvailable)) {
        throw "The Active Directory module for Windows PowerShell is not installed. Please install RSAT-AD-PowerShell."
    }

    #============================================================================
    # PHASE 1: BULK DATA ACQUISITION AND CACHING
    #============================================================================
    Write-Host "Phase 1: Starting bulk data acquisition from Active Directory..."

    # 1.1: Get the primary list of users
    Write-Verbose "Retrieving target users with LDAP filter: $LDAPFilter"
    $adUsers = Get-ADUser -LDAPFilter $LDAPFilter -Properties manager, whenCreated, pwdLastSet, memberOf, company, DistinguishedName -ErrorAction Stop
    if ($null -eq $adUsers) { throw "No users found matching the specified LDAP filter. Halting execution." }
    Write-Host "$($adUsers.Count) users retrieved for processing."

    # 1.2: Pre-cache "in-scope" groups
    Write-Verbose "Caching 'in-scope' group information..."
    $inScopeGroupLookup = @{}
    if ($InScopeGroupNames.Count -gt 0) {
        $groupFilter = '(|' + ($InScopeGroupNames | ForEach-Object { "(sAMAccountName=$_)" }) + ')'
        Get-ADGroup -LDAPFilter $groupFilter | ForEach-Object { $inScopeGroupLookup[$_.DistinguishedName] = $_.sAMAccountName }
    }
    Write-Host "$($inScopeGroupLookup.Count) 'in-scope' groups cached."
    
    # 1.3: Pre-cache members of the non-interactive group
    Write-Verbose "Caching members of the '$NonInteractiveGroupName' group..."
    $nonInteractiveUserCache = @{}
    try {
        $denyGroupMembers = Get-ADGroupMember -Identity $NonInteractiveGroupName -ErrorAction Stop
        foreach ($member in $denyGroupMembers) { $nonInteractiveUserCache[$member.DistinguishedName] = $true }
        Write-Host "$($nonInteractiveUserCache.Count) non-interactive users cached."
    }
    catch { Write-Warning "Could not find the group '$NonInteractiveGroupName'. All users will be marked as Interactive." }

    # 1.4: Pre-cache all potential _RW and _RO groups, their managers, AND their member lists
    Write-Verbose "Generating list of all potential _RW and _RO groups..."
    $potentialGroupNames = [System.Collections.Generic.List[string]]::new()
    foreach ($user in $adUsers) {
        $potentialGroupNames.Add("$($user.sAMAccountName)_RW")
        $potentialGroupNames.Add("$($user.sAMAccountName)_RO")
    }

    Write-Verbose "Querying AD for all existing _RW/_RO groups, their managers, and members..."
    $rwGroupCache = @{}
    $roGroupCache = @{}
    $batchSize = 400
    $groupCount = $potentialGroupNames.Count
    for ($i = 0; $i -lt $groupCount; $i += $batchSize) {
        $batch = $potentialGroupNames.GetRange($i, [System.Math]::Min($batchSize, $groupCount - $i))
        $groupLDAPFilter = "(|" + ($batch | ForEach-Object { "(sAMAccountName=$_)" }) + ")"
        $foundGroups = Get-ADGroup -LDAPFilter $groupLDAPFilter -Properties managedBy, member -ErrorAction SilentlyContinue
        foreach ($group in $foundGroups) {
            if ($group.sAMAccountName.EndsWith("_RW")) { $rwGroupCache[$group.sAMAccountName] = $group }
            elseif ($group.sAMAccountName.EndsWith("_RO")) { $roGroupCache[$group.sAMAccountName] = $group }
        }
    }
    Write-Host "$($rwGroupCache.Count) _RW groups and $($roGroupCache.Count) _RO groups cached."

    #============================================================================
    # PHASE 2: PER-USER PROCESSING AND DATA ENRICHMENT
    #============================================================================
    Write-Host "Phase 2: Starting per-user processing and data enrichment..."
    $resultsList = [System.Collections.ArrayList]::new()
    $totalUsers = $adUsers.Count
    $processedCount = 0
    $today = (Get-Date).Date

    foreach ($user in $adUsers) {
        $processedCount++
        Write-Progress -Activity "Processing Users" -Status "Processing $($user.sAMAccountName) ($processedCount of $totalUsers)" -PercentComplete (($processedCount / $totalUsers) * 100)

        $reportObject = [PSCustomObject]@{
            sAMAccountName         = $user.sAMAccountName
            AccountType            = 'Interactive'
            ManagerSAM             = ''
            ManagerName            = ''
            ManagerEmail           = ''
            ManagerDepartment      = ''
            WhenCreated            = $user.whenCreated
            PasswordLastSet        = 'Never'
            DaysSincePasswordReset = 'N/A'
            InScopeGroups          = ''
            RW_GroupExists         = 'No'
            RO_GroupExists         = 'No'
            RW_GroupManagerSAM     = ''
            RO_GroupManagerSAM     = ''
            ManagerInRW_Group      = 'N/A'
            ManagerInRO_Group      = 'N/A'
            RW_ManagerMatch        = 'No'
            RO_ManagerMatch        = 'No'
        }
        
        $passwordLastSetDate = if ($user.pwdLastSet -gt 0) { [datetime]::FromFileTime($user.pwdLastSet) } else { $null }
        if ($passwordLastSetDate) {
            $reportObject.PasswordLastSet = $passwordLastSetDate
            $reportObject.DaysSincePasswordReset = ($today - $passwordLastSetDate.Date).Days
        }

        if ($nonInteractiveUserCache.ContainsKey($user.DistinguishedName)) {
            $reportObject.AccountType = 'Non-Interactive'
        }
        
        $managerUser = $null
        if (-not [string]::IsNullOrEmpty($user.manager)) {
            try {
                $managerUser = Get-ADUser -Identity $user.manager -Properties sAMAccountName, Name, EmailAddress, Department, DistinguishedName -ErrorAction Stop
                $reportObject.ManagerSAM = $managerUser.sAMAccountName
                $reportObject.ManagerName = $managerUser.Name
                $reportObject.ManagerEmail = $managerUser.EmailAddress
                $reportObject.ManagerDepartment = $managerUser.Department
            } catch { Write-Warning "Could not resolve manager with DN '$($user.manager)' for user '$($user.sAMAccountName)'. Error: $($_.Exception.Message)" }
        }

        $userInScopeGroups = @()
        foreach ($groupDN in $user.memberOf) { if ($inScopeGroupLookup.ContainsKey($groupDN)) { $userInScopeGroups += $inScopeGroupLookup[$groupDN] } }
        $reportObject.InScopeGroups = $userInScopeGroups -join ", "

        $rwGroupName = "$($user.sAMAccountName)_RW"
        if ($rwGroupCache.ContainsKey($rwGroupName)) {
            $reportObject.RW_GroupExists = 'Yes'
            $rwGroup = $rwGroupCache[$rwGroupName]
            $reportObject.ManagerInRW_Group = 'No'
            if ($rwGroup.managedBy) {
                try {
                    $rwManagerUser = Get-ADUser -Identity $rwGroup.managedBy -Properties sAMAccountName -ErrorAction Stop
                    $reportObject.RW_GroupManagerSAM = $rwManagerUser.sAMAccountName
                } catch { Write-Warning "Could not resolve manager for group '$($rwGroup.sAMAccountName)'. Error: $($_.Exception.Message)" }
            }
            if ($managerUser -and $rwGroup.member -contains $managerUser.DistinguishedName) {
                $reportObject.ManagerInRW_Group = 'Yes'
            }
        }

        $roGroupName = "$($user.sAMAccountName)_RO"
        if ($roGroupCache.ContainsKey($roGroupName)) {
            $reportObject.RO_GroupExists = 'Yes'
            $roGroup = $roGroupCache[$roGroupName]
            $reportObject.ManagerInRO_Group = 'No'
            if ($roGroup.managedBy) {
                try {
                    $roManagerUser = Get-ADUser -Identity $roGroup.managedBy -Properties sAMAccountName -ErrorAction Stop
                    $reportObject.RO_GroupManagerSAM = $roManagerUser.sAMAccountName
                } catch { Write-Warning "Could not resolve manager for group '$($roGroup.sAMAccountName)'. Error: $($_.Exception.Message)" }
            }
            if ($managerUser -and $roGroup.member -contains $managerUser.DistinguishedName) {
                $reportObject.ManagerInRO_Group = 'Yes'
            }
        }

        # ✨ FIX: Trim whitespace from SAM account names before comparing them for a reliable match.
        if (($reportObject.ManagerSAM -ne '') -and ($reportObject.RW_GroupManagerSAM -ne '') -and ($reportObject.ManagerSAM.Trim() -eq $reportObject.RW_GroupManagerSAM.Trim())) { $reportObject.RW_ManagerMatch = 'Yes' }
        if (($reportObject.ManagerSAM -ne '') -and ($reportObject.RO_GroupManagerSAM -ne '') -and ($reportObject.ManagerSAM.Trim() -eq $reportObject.RO_GroupManagerSAM.Trim())) { $reportObject.RO_ManagerMatch = 'Yes' }

        [void]$resultsList.Add($reportObject)
    }

    #============================================================================
    # EXPORT RESULTS
    #============================================================================
    Write-Host "Processing complete. Exporting $($resultsList.Count) records to CSV..."
    if ($resultsList.Count -gt 0) {
        $resultsList | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8
        Write-Host "Successfully exported report to: $OutputPath"
    } else { Write-Warning "No data was generated to export." }

}
catch {
    $errorMessage = "A fatal error occurred: $($_.Exception.Message)"
    Write-Error $errorMessage
}
finally {
    Write-Host "Script execution finished. Stopping transcript."
    Stop-Transcript
}
