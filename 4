<#
.SYNOPSIS
    Generates a comprehensive report on specified Active Directory users, including password expiry details, a phased rotation plan, and detailed group/manager analysis.
.DESCRIPTION
    This script retrieves a list of Active Directory users from one of two sources:
    1. A configurable LDAP filter.
    2. An input CSV or TXT file containing a list of sAMAccountNames.
 
    For each user, it reports on their sAMAccountName, account type (Interactive/Non-Interactive),
    detailed manager information, and creation date. It automatically detects membership in password
    rotation groups (defined in a configurable map) to calculate and report on the applicable
    password policy, expiry date, and days remaining.

    It then assigns each account to a rotation phase (1-4) based on the calendar quarter of its expiry date
    and provides an analytical comments field with notification dates and actionable warnings.

    Finally, it verifies the existence of corresponding _RW and _RO groups, their managers, and checks
    if the user's manager is a member of those groups.
.NOTES
    Version: 4.1
    Author: Senior PowerShell and Active Directory Automation Specialist
    Prerequisites: Active Directory module for Windows PowerShell (RSAT-AD-PowerShell).
    Permissions: The executing account needs read permissions for user and group objects in Active Directory.
#>

#================================================================================
# SCRIPT EXECUTION WRAPPER WITH LOGGING AND ERROR HANDLING
#================================================================================
Try {
    #----------------------------------------------------------------------------
    # CONFIGURATION
    #----------------------------------------------------------------------------
    # Modify the variables in this section to suit your environment and needs.

    # Path for the final CSV report. A timestamp will be added automatically.
    $OutputPath = "D:\IAM_TEAM\Steven\GETServiceAccountsListAD\ServiceAccountsReport_RO_RW.csv"

    # Directory for the transcript log file.
    $LogPath = "D:\IAM_TEAM\Steven\GETServiceAccountsListAD"

    # --- CHOOSE ONE INPUT METHOD ---
    # Method 1: Specify a path to a CSV/TXT file to read sAMAccountNames from.
    # If this is set to a valid path, the LDAPFilter will be IGNORED.
    $InputCsvPath = "D:\IAM_TEAM\Steven\GETServiceAccountsListAD\input.txt"
    # The name of the column in the CSV that contains the sAMAccountNames.
    $CsvHeaderName = "sAMAccountName"

    # Method 2: Use an LDAP filter. Leave $InputCsvPath as $null or an empty string to use this.
    $LDAPFilter = "(&(objectCategory=person)(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2))(|(company=*Resource*)(company=Resource-Service))(!(company=Resource-Admin)))"

    # --- GROUP AND POLICY DEFINITIONS ---
    # An array of all groups to check for membership. This includes password policy groups.
    $InScopeGroupNames = @(
        "GoogleInteractive_InScopeAccounts", 
        "GoogleInteractive_Phase3", 
        "GoogleInteractive_Phase4",
        "PS_SvcAcc_90DaysRotation",
        "PS_SvcAcc_365DaysRotation",
        "PS_SvcAcc_30DaysRotation",
        "PS_SvcAcc_180DaysRotation",
        "PS_SvcAcc_NoRotation"
    )

    # The group that defines an account as "Non-Interactive".
    $NonInteractiveGroupName = "Deny_InteractiveLogon"

    # A map defining the password rotation policy based on group membership.
    # Key = Group sAMAccountName, Value = Password age in days. -1 means no rotation.
    $RotationPolicyMap = @{
        'PS_SvcAcc_NoRotation'      = -1
        'PS_SvcAcc_30DaysRotation'  = 30
        'PS_SvcAcc_90DaysRotation'  = 90
        'PS_SvcAcc_180DaysRotation' = 180
        'PS_SvcAcc_365DaysRotation' = 365
    }
    
    # Number of days before expiry to send a notification for the phased plan.
    $NotificationLeadTimeDays = 30

    #----------------------------------------------------------------------------
    # INITIALIZATION
    #----------------------------------------------------------------------------
    if (-not (Test-Path -Path $LogPath -PathType Container)) {
        Write-Verbose "Log directory not found. Creating it at: $LogPath"
        New-Item -Path $LogPath -ItemType Directory -Force | Out-Null
    }
    $Timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
    $TranscriptPath = Join-Path -Path $LogPath -ChildPath "AD_User_Report_$Timestamp.log"
    Start-Transcript -Path $TranscriptPath
    Write-Host "Script execution started. Logging to: $TranscriptPath"

    if (-not (Get-Module -Name ActiveDirectory -ListAvailable)) {
        throw "The Active Directory module for Windows PowerShell is not installed. Please install RSAT-AD-PowerShell."
    }

    # Add timestamp to output file path
    $baseName =::GetFileNameWithoutExtension($OutputPath)
    $extension =::GetExtension($OutputPath)
    $directory =::GetDirectoryName($OutputPath)
    $OutputPath = Join-Path -Path $directory -ChildPath "$baseName`_$Timestamp$extension"

    #============================================================================
    # PHASE 1: BULK DATA ACQUISITION AND CACHING
    #============================================================================
    Write-Host "Phase 1: Starting bulk data acquisition from Active Directory..."

    $adUsers = $null
    if (-not [string]::IsNullOrEmpty($InputCsvPath) -and (Test-Path -Path $InputCsvPath -PathType Leaf)) {
        Write-Host "Input CSV file specified. Reading users from: $InputCsvPath"
        try {
            $samAccountNames = (Import-Csv -Path $InputCsvPath).$CsvHeaderName
            if ($null -eq $samAccountNames -or $samAccountNames.Count -eq 0) {
                throw "CSV file is empty or the header '$CsvHeaderName' was not found."
            }
            $userFilterFromCsv = '(|' + ($samAccountNames | ForEach-Object { "(sAMAccountName=$_)" }) + ')'
            $adUsers = Get-ADUser -LDAPFilter $userFilterFromCsv -Properties manager, whenCreated, pwdLastSet, memberOf, company, DistinguishedName -ErrorAction Stop
        }
        catch {
            throw "Failed to read or process the input CSV file '$InputCsvPath'. Error: $($_.Exception.Message)"
        }
    }
    else {
        Write-Host "Using LDAP filter to retrieve users."
        $adUsers = Get-ADUser -LDAPFilter $LDAPFilter -Properties manager, whenCreated, pwdLastSet, memberOf, company, DistinguishedName -ErrorAction Stop
    }

    if ($null -eq $adUsers) { throw "No users found based on the specified input method. Halting execution." }
    Write-Host "$($adUsers.Count) users retrieved for processing."

    # 1.2: Pre-cache all "in-scope" groups
    Write-Verbose "Caching in-scope group information..."
    $inScopeGroupLookup = @{}
    if ($InScopeGroupNames.Count -gt 0) {
        $groupFilter = '(|' + ($InScopeGroupNames | ForEach-Object { "(sAMAccountName=$_)" }) + ')'
        Get-ADGroup -LDAPFilter $groupFilter | ForEach-Object { $inScopeGroupLookup = $_.sAMAccountName }
    }
    Write-Host "$($inScopeGroupLookup.Count) in-scope groups cached."
    
    # 1.3: Pre-cache members of the non-interactive group
    Write-Verbose "Caching members of the '$NonInteractiveGroupName' group..."
    $nonInteractiveUserCache = @{}
    try {
        Get-ADGroupMember -Identity $NonInteractiveGroupName -ErrorAction Stop | ForEach-Object { $nonInteractiveUserCache = $true }
        Write-Host "$($nonInteractiveUserCache.Count) non-interactive users cached."
    }
    catch { Write-Warning "Could not find or read members from the group '$NonInteractiveGroupName'. All users will be marked as Interactive." }

    # 1.4: Pre-cache all potential _RW and _RO groups and their members/managers
    $potentialGroupNames =]::new()
    foreach ($user in $adUsers) {
        $potentialGroupNames.Add("$($user.sAMAccountName)_RW")
        $potentialGroupNames.Add("$($user.sAMAccountName)_RO")
    }
    $rwGroupCache = @{}
    $roGroupCache = @{}
    $batchSize = 400
    for ($i = 0; $i -lt $potentialGroupNames.Count; $i += $batchSize) {
        $batch = $potentialGroupNames.GetRange($i,::Min($batchSize, $potentialGroupNames.Count - $i))
        $groupLDAPFilter = "(|" + ($batch | ForEach-Object { "(sAMAccountName=$_)" }) + ")"
        $foundGroups = Get-ADGroup -LDAPFilter $groupLDAPFilter -Properties managedBy, member -ErrorAction SilentlyContinue
        foreach ($group in $foundGroups) {
            if ($group.sAMAccountName.EndsWith("_RW")) { $rwGroupCache[$group.sAMAccountName] = $group }
            elseif ($group.sAMAccountName.EndsWith("_RO")) { $roGroupCache[$group.sAMAccountName] = $group }
        }
    }
    Write-Host "$($rwGroupCache.Count) _RW groups and $($roGroupCache.Count) _RO groups cached."

    #============================================================================
    # PHASE 2: PER-USER PROCESSING AND DATA ENRICHMENT
    #============================================================================
    Write-Host "Phase 2: Starting per-user processing and data enrichment..."
    $resultsList =::new()
    $today = (Get-Date).Date

    foreach ($user in $adUsers) {
        Write-Progress -Activity "Processing Users" -Status "Processing $($user.sAMAccountName)" -PercentComplete (($resultsList.Count / $adUsers.Count) * 100)

        $reportObject = [ordered]@{
            sAMAccountName          = $user.sAMAccountName
            AccountType             = 'Interactive'
            ManagerSAM              = ''
            ManagerName             = ''
            ManagerEmail            = ''
            ManagerDepartment       = ''
            WhenCreated             = $user.whenCreated
            PasswordLastSet         = 'Never'
            DaysSincePasswordReset  = 'N/A'
            InScopeGroups           = ''
            PasswordPolicyDays      = 'N/A'
            PasswordExpiryDate      = 'N/A'
            DaysUntilExpiry         = 'N/A'
            Phase                   = 'N/A'
            NotificationDate        = 'N/A'
            Comments                = ''
            RW_GroupExists          = 'No'
            RO_GroupExists          = 'No'
            RW_GroupManagerSAM      = ''
            RO_GroupManagerSAM      = ''
            ManagerInRW_Group       = 'N/A'
            ManagerInRO_Group       = 'N/A'
            RW_ManagerMatch         = 'No'
            RO_ManagerMatch         = 'No'
        }
        
        $passwordLastSetDate = if ($user.pwdLastSet -gt 0) { [datetime]::FromFileTime($user.pwdLastSet) } else { $null }
        if ($passwordLastSetDate) { $reportObject.PasswordLastSet = $passwordLastSetDate; $reportObject.DaysSincePasswordReset = ($today - $passwordLastSetDate.Date).Days }
        if ($nonInteractiveUserCache.ContainsKey($user.DistinguishedName)) { $reportObject.AccountType = 'Non-Interactive' }
        
        $managerUser = $null
        if (-not [string]::IsNullOrEmpty($user.manager)) {
            try {
                $managerUser = Get-ADUser -Identity $user.manager -Properties sAMAccountName, Name, EmailAddress, Department, DistinguishedName -ErrorAction Stop
                $reportObject.ManagerSAM = $managerUser.sAMAccountName; $reportObject.ManagerName = $managerUser.Name; $reportObject.ManagerEmail = $managerUser.EmailAddress; $reportObject.ManagerDepartment = $managerUser.Department
            } catch { Write-Warning "Could not resolve manager with DN '$($user.manager)' for user '$($user.sAMAccountName)'. Error: $($_.Exception.Message)" }
        }

        $userInScopeGroups = @(); $policyApplied = $false; $expiryDate = $null
        foreach ($groupDN in $user.memberOf) {
            if ($inScopeGroupLookup.ContainsKey($groupDN)) {
                $groupName = $inScopeGroupLookup; $userInScopeGroups += $groupName
                if (-not $policyApplied -and $RotationPolicyMap.ContainsKey($groupName)) {
                    $policyDays = $RotationPolicyMap[$groupName]
                    if ($policyDays -eq -1) { $reportObject.PasswordPolicyDays = "No Rotation" }
                    else {
                        $reportObject.PasswordPolicyDays = $policyDays
                        if ($passwordLastSetDate) { 
                            $expiryDate = $passwordLastSetDate.AddDays($policyDays)
                            $reportObject.PasswordExpiryDate = $expiryDate.ToString('yyyy-MM-dd')
                            $reportObject.DaysUntilExpiry = ($expiryDate.Date - $today).Days 
                        }
                    }
                    $policyApplied = $true
                }
            }
        }
        $reportObject.InScopeGroups = $userInScopeGroups -join ", "

        # --- Phased Rotation Plan Logic ---
        if ($reportObject.PasswordPolicyDays -eq 'No Rotation') {
            $reportObject.Comments = "Account is exempt from password rotation policy."
        }
        elseif ($expiryDate) {
            $notificationDate = $expiryDate.AddDays(-$NotificationLeadTimeDays)
            $expiryMonth = $expiryDate.Month
            
            $phase = switch ($expiryMonth) {
                { $_ -in 1..3 }   { "Phase 1" }
                { $_ -in 4..6 }   { "Phase 2" }
                { $_ -in 7..9 }   { "Phase 3" }
                { $_ -in 10..12 } { "Phase 4" }
            }

            $reportObject.Phase = $phase
            $reportObject.NotificationDate = $notificationDate.ToString('yyyy-MM-dd')
            $reportObject.Comments = "Expires in Q$([math]::Ceiling($expiryMonth/3)). Notification due on $($notificationDate.ToString('yyyy-MM-dd')). Recommended reset window: $($notificationDate.ToString('yyyy-MM-dd')) to $($expiryDate.ToString('yyyy-MM-dd'))."
        }
        elseif (-not $passwordLastSetDate) {
            $reportObject.Comments = "ACTION REQUIRED: Password was never set or user must change at next logon (pwdLastSet is 0)."
        }
        else {
            $reportObject.Comments = "No rotation policy group found for this user."
        }

        $rwGroupName = "$($user.sAMAccountName)_RW"
        if ($rwGroupCache.ContainsKey($rwGroupName)) {
            $reportObject.RW_GroupExists = 'Yes'; $reportObject.ManagerInRW_Group = 'No'; $rwGroup = $rwGroupCache[$rwGroupName]
            if ($rwGroup.managedBy) { try { $reportObject.RW_GroupManagerSAM = (Get-ADUser -Identity $rwGroup.managedBy -Properties sAMAccountName -EA Stop).sAMAccountName } catch { Write-Warning "Could not resolve manager for group '$rwGroupName'."} }
            if ($managerUser -and $rwGroup.member -contains $managerUser.DistinguishedName) { $reportObject.ManagerInRW_Group = 'Yes' }
        }

        $roGroupName = "$($user.sAMAccountName)_RO"
        if ($roGroupCache.ContainsKey($roGroupName)) {
            $reportObject.RO_GroupExists = 'Yes'; $reportObject.ManagerInRO_Group = 'No'; $roGroup = $roGroupCache[$roGroupName]
            if ($roGroup.managedBy) { try { $reportObject.RO_GroupManagerSAM = (Get-ADUser -Identity $roGroup.managedBy -Properties sAMAccountName -EA Stop).sAMAccountName } catch { Write-Warning "Could not resolve manager for group '$roGroupName'."} }
            if ($managerUser -and $roGroup.member -contains $managerUser.DistinguishedName) { $reportObject.ManagerInRO_Group = 'Yes' }
        }

        if (($reportObject.ManagerSAM -ne '') -and ($reportObject.RW_GroupManagerSAM -ne '') -and ($reportObject.ManagerSAM.Trim() -eq $reportObject.RW_GroupManagerSAM.Trim())) { $reportObject.RW_ManagerMatch = 'Yes' }
        if (($reportObject.ManagerSAM -ne '') -and ($reportObject.RO_GroupManagerSAM -ne '') -and ($reportObject.ManagerSAM.Trim() -eq $reportObject.RO_GroupManagerSAM.Trim())) { $reportObject.RO_ManagerMatch = 'Yes' }

        [void]$resultsList.Add([pscustomobject]$reportObject)
    }

    #============================================================================
    # EXPORT RESULTS
    #============================================================================
    Write-Host "`nProcessing complete. Exporting $($resultsList.Count) records to CSV..."
    if ($resultsList.Count -gt 0) {
        $resultsList | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8
        Write-Host "Successfully exported report to: $OutputPath"
    } else { Write-Warning "No data was generated to export." }

}
catch {
    $errorMessage = "A fatal error occurred: $($_.Exception.Message)"
    Write-Error $errorMessage
}
finally {
    Write-Host "Script execution finished. Stopping transcript."
    Stop-Transcript
}
